# Layered-Architecture
계층형 아키텍처(Layered Architecture, 레이어드 아키텍처)

## 계층형 아키텍처란 ##
- 전통적인 아키텍처
- 영속성 계층을 토대로 만들지기 때문에 데이터베이스에 의존적이다. 그러므로 데이터베이스 중심으로 설계가 진행된다.
- 3계층 혹은 4계층으로 나누어진다.

![Da drawio](https://user-images.githubusercontent.com/24876345/219259022-9dbfa424-8be8-42e3-95e2-2731b0cc812c.png){: width="380" }
<img src = "https://user-images.githubusercontent.com/24876345/219259022-9dbfa424-8be8-42e3-95e2-2731b0cc812c.png" width="350px">


### 웹( presentation layer ) ###
- 유저 인터페이스나 브라우저 커뮤니케이션 로직을 다룬다.
- 메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보내는 역할

### 도메인 ###
- 주요 로직을 수행하고 도메인 엔티티의 현재 상태를 조회 및 변경하기 위해 영속성 계층과 통신

### 영속성 ( Persistence ) ###
- 영속성은 엔티티를 영구 저장하는 환경을 의미한다.

## 계층형 아키텍처 문제 ##

### 1. 설계 문제 ###
- 변경에 용이하지만 코드에 나쁜 습관들이 스며들기 쉽게 만들고 시간이 지남에 따라 유지보수 난이도가 올라갈 수 있게 하는 허점이 있다.

### 2. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다. ###
- 좋은 객체지향 설계를 위해서는 각 객체가 수행해야 할 역할과 행동들을 중심으로 객체간 관계를 모델링 한다.
- 또한, 모델링한 행동들에 따라 어플리케이션의 상태가 변경된다.
- 하지만 계층형 아키텍처에서 의존성의 방향이 아래 계층을 향하고 데이터베이스의 구조를 먼저 생각하고 이를 토대로 도메인 로직을 구현하게 된다.
- 데이터 베이스 계층을 중심으로 아키텍처가 만들어지는 이유는 ORM을 사용하기 때문이다.

### 3. 비즈니스 레이어와 영속성 레이어 간의 결합 문제 ###
- 엔티티들을 일반적으로 영속성 계층에 주로 두는데 서비스가 영속성 모델을 비즈니스 모델처럼 사용하게 된다.
- 도메인 레이어의 서비스 컴포넌트는 도메인 로직뿐만 아니라 즉시로딩/지연로딩, 데이터베이스 트랜잭션, 캐시 플러시등 영속성 계층에서 담당해야 할 역할들을 수행하게 된다.
- 이는 영속성 계층과 도메인 계층 사이에 강한 결합을 생기게 하여 변경에 용이하지 않은 아키텍처를 만들게 한다.
- 객체와 객체간의 강한 결합성이 생긴다면 한 객체가 한 객체에 의존하는 형태를 띄게 되고 이것은 좋은 변경에 용이한 설계라고 할 수 없다.

### 4. 지름길 ###
- 계층형 아키텍처에서 존재하는 유일한 제약조건은 하위 계층이 상위 계층에 접근하지 못한다는 것이다.
- 하위에서 상위 계층을 접근하고 싶다면 컴포넌트를 한 계층 아래로 내려버리면 된다. 이러한 접근 방법을 지름길 이라고 한다.

### 5. 테스트하기 어려워진다. ###
- 웹 계층 테스트를 할 때, 도메인 계층 뿐만 아니라 영속성 계층도 모킹하기때문에 단위 테스트 복잡도가 올라가게 된다.

### 6. 유즈케이스를 숨긴다. ###
- 좋은 아키텍처는 기능을 추가하거나 변경할 때 변경할 적절한 위치를 찾는 일에도 도움을 주어야 한다.
- 계층형 아키텍처가 좋은 선택이 되지 못하는 이유는 다음과 같다.
    + 데이터 베이스 기반의 설계로 인해 비즈니스 규칙과 영속성 계층간의 결합성이 높아져 어느 곳을 수정해야 하는 지에 대한 통일성이 낮아진다.
    + 계층형 아키텍처에서 지름길을 선택하는 일이 빈번해져 한 계층의 너비가 비대해진다면 한 계층에서만 여러 개의 유즈케이스를 담당하게 된다. 
    + 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고 작업해야 할 유즈 케이스를 책임지는 서비스를 찾는 것도 어려워진다.

### 7. 동시작업 ###
- 도메인 로직이 여기저기 퍼져 있어서 어디 코드를 수정할 지 파악하기 어렵기 때문에 프로젝트 작업 시간이 길어진다.
- 또한 얼마나 많은 리소스를 배정해야 일정에 맞춰 개발 할 수 있을지 예측하는데 어려워진다.

게다가 계층형 아키텍처를 개발할 때 각 레이어를 한 사람씩 맡아서 동시에 작업할 수 없습니다. 상위 계층을 작업하기 위해서는 하위 계층의 작업이 선행되어야 합니다. 따라서 특정 기능을 동시 작업하는 것은 매우 어려운 일입니다.

출처: https://velog.io/@jay/%EC%89%BD%EA%B2%8C-%EB%A7%90%ED%95%98%EB%8A%94-%EA%B3%84%EC%B8%B5%ED%98%95-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EB%AC%B8%EC%A0%9C#%EA%B3%84%EC%B8%B5%ED%98%95-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80

## 계층형 아키텍처 단점 해결방법 ##

### 의존성 역전하기 ###

#### 1. 단일책임원칙 ####
- Single Responsibility Principal [[SRP자세하게알아보기]](https://github.com/orange601/Java-Solid/tree/main/1.%20SRP)
- 컴포넌트를 변경하는 이유는 오직 하나일 수 있도록 구조화하기

#### 2. 의존성역전원칙 ####
- Dependency Inversion Principle [[DIP자세하게알아보기]](https://github.com/orange601/Java-Solid/tree/main/5.%20DIP)
- 영속성 계층에 변화가 생길시 도메인 계층도 변경해야하는 경우가 많다.
